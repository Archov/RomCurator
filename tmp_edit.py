from pathlib import Path

path = Path("scripts/seeders/matching_engine.py")
text = path.read_text()
needle = "    def get_linked_platform_ids(self, platform_id: int) -> List[int]:\n        \"\"\"Get platform IDs linked to the given platform (including itself).\"\"\"\n        cursor = self.conn.cursor()\n\n        linked_ids = {platform_id}\n\n        # Gather direct mappings from the canonical platform to DAT platforms\n        cursor.execute(\"\"\"\n            SELECT DISTINCT dat_platform_id\n            FROM platform_links\n            WHERE atomic_platform_id = ?\n        \"\"\", (platform_id,))\n        linked_ids.update(row['dat_platform_id'] for row in cursor.fetchall() if row['dat_platform_id'] is not None)\n\n        # If this platform appears as an alias (DAT side), pull the canonical targets and include their DAT mappings\n        cursor.execute(\"\"\"\n            SELECT DISTINCT atomic_platform_id\n            FROM platform_links\n            WHERE dat_platform_id = ?\n        \"\"\", (platform_id,))\n        reverse_atomic_ids = [row['atomic_platform_id'] for row in cursor.fetchall() if row['atomic_platform_id'] is not None]\n\n        if reverse_atomic_ids:\n            placeholders = ','.join('?' for _ in reverse_atomic_ids)\n            cursor.execute(f\"\"\"\n                SELECT DISTINCT dat_platform_id\n                FROM platform_links\n                WHERE atomic_platform_id IN ({placeholders})\n            \"\"\", reverse_atomic_ids)\n            linked_ids.update(row['dat_platform_id'] for row in cursor.fetchall() if row['dat_platform_id'] is not None)\n\n        # Filter out any residual None values\n        return sorted(pid for pid in linked_ids if pid is not None)\n\n"""
start = text.find(needle)
if start == -1:
    raise SystemExit("Function signature block not found")
end = start + len(needle)
replacement = "    def get_linked_platform_ids(self, platform_id: int) -> List[int]:\n        \"\"\"Return DAT platform IDs linked to the given platform via mappings.\"\"\"\n        cursor = self.conn.cursor()\n\n        linked_ids = set()\n\n        # Direct mappings from the canonical platform to DAT platforms\n        cursor.execute(\"\"\"\n            SELECT DISTINCT dat_platform_id\n            FROM platform_links\n            WHERE atomic_platform_id = ?\n        \"\"\", (platform_id,))\n        linked_ids.update(row['dat_platform_id'] for row in cursor.fetchall() if row['dat_platform_id'] is not None)\n\n        # If this platform appears as a DAT alias, follow it back to the canonical platforms\n        cursor.execute(\"\"\"\n            SELECT DISTINCT atomic_platform_id\n            FROM platform_links\n            WHERE dat_platform_id = ?\n        \"\"\", (platform_id,))\n        reverse_atomic_ids = [row['atomic_platform_id'] for row in cursor.fetchall() if row['atomic_platform_id'] is not None)\n\n        if reverse_atomic_ids:\n            placeholders = ','.join('?' for _ in reverse_atomic_ids)\n            cursor.execute(f\"\"\"\n                SELECT DISTINCT dat_platform_id\n                FROM platform_links\n                WHERE atomic_platform_id IN ({placeholders})\n            \"\"\", reverse_atomic_ids)\n            linked_ids.update(row['dat_platform_id'] for row in cursor.fetchall() if row['dat_platform_id'] is not None)\n\n        # Only return DAT platform IDs that are explicitly linked\n        return sorted(linked_ids)\n\n"""
text = text.replace(needle, replacement, 1)
path.write_text(text)
